# 詳細画面スマートデバウンス自動保存機能 実装計画書

## 📋 プロジェクト概要
詳細画面（details.html）の手動「更新を保存」ボタンを、スマートデバウンス自動保存に変更する

## 🎯 実装目標
- ユーザーの入力・操作を3秒間監視して自動保存
- DB負荷を最小限に抑制
- 保存状態の視覚的フィードバック提供
- エラー処理とリトライ機能の実装

## 📊 現在の保存対象フィールド分析

### 1. タスクチェックボックス
- **現在**: チェック後に手動「更新を保存」
- **変更後**: チェック変更から3秒後に自動保存
- **頻度**: 高頻度（月次作業の核心）
- **重要度**: ⭐⭐⭐⭐⭐

### 2. URL入力フィールド
- **現在**: 入力後に手動「更新を保存」  
- **変更後**: 入力停止から3秒後に自動保存
- **頻度**: 中頻度
- **重要度**: ⭐⭐⭐

### 3. メモ入力フィールド
- **現在**: 入力後に手動「更新を保存」
- **変更後**: 入力停止から3秒後に自動保存  
- **頻度**: 中頻度（長文入力あり）
- **重要度**: ⭐⭐⭐

### 4. ステータス変更
- **現在**: 変更後に手動「更新を保存」
- **変更後**: 変更から3秒後に自動保存
- **頻度**: 低頻度
- **重要度**: ⭐⭐⭐⭐

## 🚀 実装ステップ

### Phase 1: ブランチ作成とベース実装 (30分)

#### Step 1.1: 新しいブランチ作成
```bash
git checkout -b feature/auto-save-details
```

#### Step 1.2: 自動保存クラスの設計
```javascript
// details.js に追加する AutoSaveManager クラス
class AutoSaveManager {
    constructor(saveFunction, debounceTime = 3000) {
        this.saveFunction = saveFunction;
        this.debounceTime = debounceTime;
        this.saveTimer = null;
        this.isOnline = true;
        this.pendingData = null;
    }
    
    // スマートデバウンス実行
    scheduleSave(data) { }
    
    // 保存実行
    async executeSave() { }
    
    // 保存状態表示
    updateSaveStatus(status) { }
    
    // エラーハンドリング
    handleSaveError(error) { }
}
```

#### Step 1.3: 保存状態インジケーターのHTML追加
```html
<!-- details.html のヘッダー部分に追加 -->
<div id="autosave-indicator" style="position: fixed; top: 10px; right: 10px; z-index: 1000; padding: 8px 12px; border-radius: 4px; background: #f8f9fa; border: 1px solid #dee2e6;">
    <span id="save-status">💾 準備完了</span>
</div>
```

### Phase 2: 基本自動保存機能の実装 (45分)

#### Step 2.1: AutoSaveManager クラスの詳細実装
```javascript
class AutoSaveManager {
    constructor() {
        this.debounceTime = 3000; // 3秒
        this.saveTimer = null;
        this.isSaving = false;
        this.lastSaveTime = 0;
        this.retryCount = 0;
        this.maxRetries = 3;
        this.pendingChanges = false;
        
        this.initializeIndicator();
        this.setupNetworkMonitoring();
    }
    
    scheduleSave() {
        // 既存のタイマーをクリア
        clearTimeout(this.saveTimer);
        
        // 保存中でなければデバウンスタイマーを設定
        if (!this.isSaving) {
            this.updateStatus('⏳ 保存待機中...', 'waiting');
            this.pendingChanges = true;
            
            this.saveTimer = setTimeout(() => {
                this.executeSave();
            }, this.debounceTime);
        }
    }
    
    async executeSave() {
        if (this.isSaving) return;
        
        try {
            this.isSaving = true;
            this.updateStatus('💾 保存中...', 'saving');
            
            // 既存のsaveProgress関数を呼び出し
            await saveProgress();
            
            this.pendingChanges = false;
            this.lastSaveTime = Date.now();
            this.retryCount = 0;
            this.updateStatus('✅ 保存完了', 'saved');
            
            // 3秒後に準備完了状態に戻す
            setTimeout(() => {
                if (!this.pendingChanges) {
                    this.updateStatus('💾 準備完了', 'ready');
                }
            }, 3000);
            
        } catch (error) {
            this.handleSaveError(error);
        } finally {
            this.isSaving = false;
        }
    }
    
    handleSaveError(error) {
        this.retryCount++;
        
        if (this.retryCount <= this.maxRetries) {
            this.updateStatus(`⚠️ リトライ中... (${this.retryCount}/${this.maxRetries})`, 'retrying');
            
            setTimeout(() => {
                this.executeSave();
            }, 1000 * this.retryCount); // 指数的待機時間
        } else {
            this.updateStatus('❌ 保存失敗', 'error');
            showToast('自動保存に失敗しました。手動で保存してください。', 'error');
            
            // 手動保存ボタンを表示
            this.showManualSaveButton();
        }
    }
    
    updateStatus(message, type) {
        const indicator = document.getElementById('save-status');
        if (indicator) {
            indicator.textContent = message;
            
            // 状態に応じた色分け
            const colors = {
                ready: '#28a745',
                waiting: '#ffc107', 
                saving: '#17a2b8',
                saved: '#28a745',
                retrying: '#fd7e14',
                error: '#dc3545'
            };
            
            const parentElement = document.getElementById('autosave-indicator');
            if (parentElement) {
                parentElement.style.backgroundColor = colors[type] || '#f8f9fa';
                parentElement.style.color = type === 'waiting' ? '#000' : '#fff';
            }
        }
    }
}
```

#### Step 2.2: 各入力要素へのイベントリスナー追加
```javascript
// details.js の既存初期化処理に追加
function initializeAutoSave() {
    const autoSaveManager = new AutoSaveManager();
    
    // タスクチェックボックス
    document.addEventListener('change', (e) => {
        if (e.target.type === 'checkbox' && e.target.name === 'task') {
            autoSaveManager.scheduleSave();
        }
    });
    
    // URL入力フィールド
    document.addEventListener('input', (e) => {
        if (e.target.classList.contains('url-input')) {
            autoSaveManager.scheduleSave();
        }
    });
    
    // メモ入力フィールド  
    document.addEventListener('input', (e) => {
        if (e.target.classList.contains('memo-input')) {
            autoSaveManager.scheduleSave();
        }
    });
    
    // ステータス変更
    document.addEventListener('change', (e) => {
        if (e.target.classList.contains('status-select')) {
            autoSaveManager.scheduleSave();
        }
    });
}
```

### Phase 3: UI改善とエラー処理強化 (30分)

#### Step 3.1: 手動保存ボタンの改修
```javascript
// 既存の更新を保存ボタンを緊急保存ボタンに変更
function updateSaveButton() {
    const saveButton = document.getElementById('save-button');
    if (saveButton) {
        saveButton.textContent = '🚨 今すぐ保存';
        saveButton.title = '自動保存を待たずに即座保存';
        
        saveButton.addEventListener('click', async () => {
            // 自動保存タイマーをクリア
            clearTimeout(autoSaveManager.saveTimer);
            
            // 即座に保存実行
            await autoSaveManager.executeSave();
            
            showToast('✅ 手動保存が完了しました', 'success');
        });
    }
}
```

#### Step 3.2: オフライン対応
```javascript
// AutoSaveManager に追加
setupNetworkMonitoring() {
    window.addEventListener('online', () => {
        this.updateStatus('🌐 オンライン復帰', 'ready');
        
        // オフライン中の変更があれば保存
        if (this.pendingChanges) {
            this.scheduleSave();
        }
    });
    
    window.addEventListener('offline', () => {
        this.updateStatus('📱 オフライン', 'offline');
        showToast('オフラインです。オンライン復帰時に自動保存されます', 'warning');
    });
}
```

#### Step 3.3: 最終確認ダイアログ（ページ離脱時）
```javascript
// 未保存データがある場合の離脱防止
window.addEventListener('beforeunload', (e) => {
    if (autoSaveManager.pendingChanges) {
        const message = '未保存の変更があります。このページを離れますか？';
        e.preventDefault();
        e.returnValue = message;
        return message;
    }
});
```

### Phase 4: テストと最適化 (30分)

#### Step 4.1: 機能テストケース
1. **基本動作テスト**
   - タスクチェック → 3秒後自動保存
   - URL入力 → 入力停止3秒後自動保存  
   - メモ入力 → 入力停止3秒後自動保存
   - ステータス変更 → 3秒後自動保存

2. **エラーケーステスト**
   - ネットワークエラー時のリトライ
   - オフライン時の動作
   - 同時操作時の競合処理

3. **パフォーマンステスト**
   - 高速入力時のデバウンス動作
   - メモリリーク確認
   - 長時間使用時の安定性

#### Step 4.2: ユーザビリティテスト
- 保存状態の視認性確認
- 保存タイミングの適切性確認  
- エラー時の分かりやすさ確認

### Phase 5: デプロイとモニタリング (15分)

#### Step 5.1: ブランチマージ準備
```bash
# テスト完了後
git add .
git commit -m "feat: スマートデバウンス自動保存機能実装

- 3秒間のデバウンス自動保存
- 保存状態の視覚的インジケーター  
- エラーハンドリングとリトライ機能
- オフライン対応
- 手動保存オプション維持

🤖 Generated with Claude Code
Co-Authored-By: Claude <noreply@anthropic.com>"
```

#### Step 5.2: 本番環境での動作確認
1. 基本機能の動作確認
2. 保存頻度の監視
3. エラー発生率の確認
4. ユーザーフィードバックの収集

## 🎯 成功指標

### 量的指標
- 手動保存ボタンのクリック数: **90%減少**
- データ保存忘れによる損失: **0件**
- 保存関連エラー率: **5%以下**
- DB API呼び出し数: **50%削減** (デバウンス効果)

### 質的指標  
- ユーザーの操作ストレス軽減
- 自動保存に対する安心感向上
- 業務効率の向上

## ⚠️ リスク対策

### 技術的リスク
- **DB負荷**: デバウンス時間の調整で対応
- **競合エラー**: リトライ機能で対応
- **データ損失**: 手動保存オプション維持

### ユーザビリティリスク
- **操作の混乱**: 明確な保存状態表示
- **信頼性の不安**: エラー時の適切な通知
- **習慣の変化**: 段階的な導入

## 📋 実装完了チェックリスト

### 基本機能
- [ ] AutoSaveManager クラス実装
- [ ] デバウンス機能実装  
- [ ] 各入力要素のイベント設定
- [ ] 保存状態インジケーター

### エラー処理
- [ ] リトライ機能実装
- [ ] オフライン対応  
- [ ] エラー通知機能
- [ ] 手動保存オプション

### UI/UX
- [ ] 保存状態の視覚化
- [ ] 適切なフィードバック
- [ ] ページ離脱防止
- [ ] レスポンシブ対応

### テスト
- [ ] 基本動作テスト
- [ ] エラーケーステスト  
- [ ] パフォーマンステスト
- [ ] ユーザビリティテスト

## 🚀 実装開始の準備完了

上記計画に基づいて、詳細画面のスマートデバウンス自動保存機能の実装準備が整いました。

次のアクション:
1. ブランチ作成の確認
2. Phase 1 の実装開始
3. 段階的な機能追加と動作確認

実装開始のご指示をお待ちしております！